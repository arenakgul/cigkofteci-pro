<!DOCTYPE html>
<html lang="tr" data-theme="dark">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Ã‡iÄŸkÃ¶fteci Pro V5 | Cloud + Tablet Senkron</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
  
  <!-- PWA Manifest -->
  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#E53935">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  
  <style>
    :root {
      --font-main: "Inter", sans-serif;
      --radius: 20px;
      --radius-sm: 14px;
      --transition: 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      --primary: #E53935;
      --primary-hover: #C62828;
      --secondary: #FF9800;
      --success: #4CAF50;
      --warning: #FFB74D;
      --danger: #D32F2F;
      --info: #2196F3;
      --bg-body: #0F1419;
      --bg-panel: #1A2029;
      --bg-panel-light: #232B36;
      --bg-input: #2D3748;
      --border: #3A4556;
      --text-main: #F7FAFC;
      --text-muted: #A0AEC0;
      --shadow: 0 20px 40px -15px rgba(0, 0, 0, 0.5);
      --gradient-primary: linear-gradient(135deg, var(--primary), var(--secondary));
    }

    html[data-theme="light"] {
      --bg-body: #F5F7FA;
      --bg-panel: #FFFFFF;
      --bg-panel-light: #F8FAFC;
      --bg-input: #EDF2F7;
      --border: #E2E8F0;
      --text-main: #1A202C;
      --text-muted: #718096;
      --shadow: 0 20px 40px -15px rgba(0, 0, 0, 0.08);
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: var(--font-main); background: var(--bg-body); color: var(--text-main); height: 100vh; overflow: hidden; display: flex; flex-direction: column; }

    /* HEADER */
    header { background: var(--bg-panel); border-bottom: 1px solid var(--border); padding: 0.75rem 2rem; display: flex; justify-content: space-between; align-items: center; z-index: 100; box-shadow: var(--shadow); }
    .brand { display: flex; align-items: center; gap: 15px; }
    .logo { background: var(--gradient-primary); color: white; padding: 12px 18px; border-radius: var(--radius-sm); font-weight: 900; font-size: 1.5rem; box-shadow: 0 8px 20px rgba(229, 57, 53, 0.3); }
    .header-controls { display: flex; align-items: center; gap: 20px; flex-wrap: wrap; }
    .save-btn { background: var(--success); color: white; border: none; padding: 10px 20px; border-radius: var(--radius-sm); font-weight: 600; cursor: pointer; display: flex; align-items: center; gap: 8px; }
    #themeToggle { background: var(--bg-input); border: 1px solid var(--border); color: var(--text-main); width: 48px; height: 48px; border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 1.2rem; }
    #themeToggle:hover { background: var(--primary); color: white; }

    /* Sync Status */
    .sync-status {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 0.85rem;
      margin-left: 10px;
    }
    .sync-status.syncing { background: rgba(33, 150, 243, 0.2); color: var(--info); }
    .sync-status.synced { background: rgba(76, 175, 80, 0.2); color: var(--success); }
    .sync-status.error { background: rgba(211, 47, 47, 0.2); color: var(--danger); }

    /* Tablet iÃ§in responsive */
    @media (max-width: 1024px) {
      .app-container { flex-direction: column; }
      nav.sidebar { width: 100%; height: 80px; flex-direction: row; justify-content: space-around; padding: 10px; }
      .nav-item { width: 60px; height: 60px; font-size: 0.65rem; }
      .pos-grid { grid-template-columns: 1fr; gap: 1rem; }
      .cart-panel { max-height: 300px; }
      .product-list { grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 1rem; }
      header { padding: 0.5rem 1rem; }
      .header-controls { gap: 10px; }
      #branchSelect { width: 180px; }
    }
    
    /* DiÄŸer CSS kurallarÄ±nÄ±z aynÄ± kalacak... */
    /* KÄ±saltma iÃ§in tÃ¼m CSS'i eklemiyorum, sadece eklenen kÄ±sÄ±mlarÄ± gÃ¶steriyorum */
  </style>
  
  <!-- TÃ¼m CSS kurallarÄ±nÄ±z burada olacak -->
  <!-- Uzunluk nedeniyle CSS'i kÄ±saltÄ±yorum, mevcut CSS'iniz aynen kalacak -->
  
</head>
<body>

  <!-- HTML'ye GÃ¶mÃ¼lÃ¼ BaÅŸlangÄ±Ã§ Verileri -->
  <script type="application/json" id="defaultData">
  {
    "categories": ["DÃ¼rÃ¼mler", "Porsiyonlar", "Ä°Ã§ecekler", "Ek Paketler"],
    "expenseTypes": ["Kira", "Elektrik FaturasÄ±", "Su FaturasÄ±", "Manav", "Mutfak Malzemesi", "Temizlik Malzemesi", "Personel", "DiÄŸer"],
    "salesChannels": ["DÃ¼kkan Ä°Ã§i", "Telefon", "Yemeksepeti", "Getir", "Trendyol Yemek"],
    "theme": "dark",
    "version": "1.0.0",
    "lastSync": null
  }
  </script>

  <!-- BaÅŸlangÄ±Ã§ Ã¼rÃ¼n verileri aynÄ± kalacak -->

  <header>
    <div class="brand">
      <div class="logo">ğŸŒ¯</div>
      <div>
        <h1 style="font-size: 1.3rem; font-weight: 800;">Ã‡iÄŸkÃ¶fteci Pro V5</h1>
        <div style="display: flex; align-items: center; gap: 10px; margin-top: 2px;">
          <span id="currentBranchName" style="font-size: 0.9rem; color: var(--text-muted);"></span>
          <div class="sync-status" id="syncStatus">ğŸ”„ Bekliyor</div>
          <div class="save-status" id="saveStatus" style="font-size: 0.8rem; color: var(--text-muted);"></div>
        </div>
      </div>
    </div>
    <div class="header-controls">
      <select id="branchSelect" style="width: 220px; padding: 10px; border-radius: 10px; background: var(--bg-input); border: 1px solid var(--border); color: var(--text-main);">
        <option value="hastane">ğŸ¥ Hastane Åubesi</option>
        <option value="cihanpol">ğŸ“ Cihanpol Åubesi</option>
      </select>
      
      <button class="save-btn" id="manualSaveBtn" title="Tablete yedek kaydet">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
          <polyline points="17 21 17 13 7 13 7 21"></polyline>
          <polyline points="7 3 7 8 15 8"></polyline>
        </svg>
        Tablete Kaydet
      </button>
      
      <button class="save-btn" id="loadBackupBtn" style="background: var(--info);" title="Tabletten yedek yÃ¼kle">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
          <polyline points="7 10 12 15 17 10"></polyline>
          <line x1="12" y1="15" x2="12" y2="3"></line>
        </svg>
        Tabletten YÃ¼kle
      </button>
      
      <button class="save-btn" id="autoSyncBtn" style="background: var(--warning); color: #000;" title="Otomatik senkron aÃ§Ä±k/kapat">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M23 4v6h-6M1 20v-6h6"></path>
          <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
        </svg>
        Oto-Senkron
      </button>
      
      <button id="themeToggle" class="btn">ğŸŒ™</button>
    </div>
  </header>

  <!-- Uygulama iÃ§eriÄŸi aynÄ± kalacak -->
  <!-- Sadece header kÄ±smÄ±nÄ± gÃ¶sterdim -->

  <script>
    // ================== KONFÄ°GÃœRASYON ==================
    const CONFIG = {
      APP_NAME: 'Ã‡iÄŸkÃ¶fteci Pro',
      VERSION: '1.0.0',
      STORAGE_KEY: 'cigkofte_pro_data',
      BACKUP_FILENAME: 'cigkofteci_yedek.json',
      AUTO_SAVE_INTERVAL: 30000, // 30 saniye
      AUTO_BACKUP_INTERVAL: 300000, // 5 dakika
      MAX_BACKUP_FILES: 10,
      USE_INDEXED_DB: true,
      ENABLE_AUTO_SYNC: true
    };

    // ================== STATE YÃ–NETÄ°MÄ° ==================
    let appState = {
      branches: {
        hastane: { products: [], sales: [], expenses: [] },
        cihanpol: { products: [], sales: [], expenses: [] }
      },
      settings: {
        theme: 'dark',
        autoSync: true,
        lastBackup: null,
        lastSync: null
      },
      metadata: {
        created: new Date().toISOString(),
        modified: new Date().toISOString(),
        version: CONFIG.VERSION
      }
    };

    let cart = [];
    let activeCat = "Hepsi";
    let activeChannel = "DÃ¼kkan Ä°Ã§i";
    let editingSaleId = null;
    let isSyncing = false;
    let autoSyncInterval = null;
    let autoSaveInterval = null;

    // ================== STORAGE YÃ–NETÄ°MÄ° ==================
    class StorageManager {
      constructor() {
        this.db = null;
        this.init();
      }

      async init() {
        if (CONFIG.USE_INDEXED_DB && 'indexedDB' in window) {
          await this.initIndexedDB();
        }
        await this.loadAllData();
      }

      async initIndexedDB() {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open(CONFIG.APP_NAME, 1);
          
          request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains('data')) {
              db.createObjectStore('data', { keyPath: 'key' });
            }
            if (!db.objectStoreNames.contains('backups')) {
              const store = db.createObjectStore('backups', { keyPath: 'timestamp' });
              store.createIndex('timestamp', 'timestamp', { unique: true });
            }
          };

          request.onsuccess = (event) => {
            this.db = event.target.result;
            resolve();
          };

          request.onerror = (event) => {
            console.error('IndexedDB hatasÄ±:', event.target.error);
            reject(event.target.error);
          };
        });
      }

      async saveToIndexedDB(key, data) {
        if (!this.db) return false;
        
        return new Promise((resolve, reject) => {
          const transaction = this.db.transaction(['data'], 'readwrite');
          const store = transaction.objectStore('data');
          const request = store.put({ key, data, timestamp: Date.now() });
          
          request.onsuccess = () => resolve(true);
          request.onerror = (event) => {
            console.error('IndexedDB kayÄ±t hatasÄ±:', event.target.error);
            reject(false);
          };
        });
      }

      async loadFromIndexedDB(key) {
        if (!this.db) return null;
        
        return new Promise((resolve) => {
          const transaction = this.db.transaction(['data'], 'readonly');
          const store = transaction.objectStore('data');
          const request = store.get(key);
          
          request.onsuccess = (event) => {
            resolve(event.target.result ? event.target.result.data : null);
          };
          
          request.onerror = () => resolve(null);
        });
      }

      async saveBackupToIndexedDB(backupData) {
        if (!this.db) return false;
        
        return new Promise((resolve, reject) => {
          const transaction = this.db.transaction(['backups'], 'readwrite');
          const store = transaction.objectStore('backups');
          const backup = {
            timestamp: Date.now(),
            data: backupData,
            size: JSON.stringify(backupData).length
          };
          
          const request = store.add(backup);
          
          request.onsuccess = async () => {
            // Eski yedekleri temizle
            await this.cleanupOldBackups();
            resolve(true);
          };
          
          request.onerror = (event) => {
            console.error('Yedek kayÄ±t hatasÄ±:', event.target.error);
            reject(false);
          };
        });
      }

      async cleanupOldBackups() {
        if (!this.db) return;
        
        const transaction = this.db.transaction(['backups'], 'readwrite');
        const store = transaction.objectStore('backups');
        const index = store.index('timestamp');
        
        const request = index.getAll();
        request.onsuccess = (event) => {
          const backups = event.target.result;
          if (backups.length > CONFIG.MAX_BACKUP_FILES) {
            backups.sort((a, b) => a.timestamp - b.timestamp);
            const toDelete = backups.slice(0, backups.length - CONFIG.MAX_BACKUP_FILES);
            
            toDelete.forEach(backup => {
              store.delete(backup.timestamp);
            });
          }
        };
      }

      // LocalStorage yedekleme (tarayÄ±cÄ± belleÄŸi)
      async saveToLocalStorage() {
        try {
          const saveData = {
            ...appState,
            metadata: {
              ...appState.metadata,
              modified: new Date().toISOString()
            }
          };
          
          localStorage.setItem(CONFIG.STORAGE_KEY, JSON.stringify(saveData));
          localStorage.setItem(`${CONFIG.STORAGE_KEY}_cart`, JSON.stringify(cart));
          localStorage.setItem(`${CONFIG.STORAGE_KEY}_last_save`, Date.now().toString());
          
          if (CONFIG.USE_INDEXED_DB && this.db) {
            await this.saveToIndexedDB('main_state', saveData);
            await this.saveToIndexedDB('cart_data', cart);
          }
          
          return true;
        } catch (error) {
          console.error('LocalStorage kayÄ±t hatasÄ±:', error);
          return false;
        }
      }

      async loadFromLocalStorage() {
        try {
          const saved = localStorage.getItem(CONFIG.STORAGE_KEY);
          const savedCart = localStorage.getItem(`${CONFIG.STORAGE_KEY}_cart`);
          
          if (saved) {
            const parsed = JSON.parse(saved);
            // VarsayÄ±lan verilerle birleÅŸtir
            appState = this.mergeWithDefaults(parsed);
          }
          
          if (savedCart) {
            cart = JSON.parse(savedCart) || [];
          }
          
          // IndexedDB'den de yÃ¼kle
          if (CONFIG.USE_INDEXED_DB && this.db) {
            const indexedData = await this.loadFromIndexedDB('main_state');
            const indexedCart = await this.loadFromIndexedDB('cart_data');
            
            if (indexedData) appState = this.mergeWithDefaults(indexedData);
            if (indexedCart) cart = indexedCart;
          }
          
          return true;
        } catch (error) {
          console.error('LocalStorage yÃ¼kleme hatasÄ±:', error);
          return false;
        }
      }

      mergeWithDefaults(savedData) {
        const defaultData = JSON.parse(document.getElementById('defaultData').textContent);
        const branchHastaneProducts = JSON.parse(document.getElementById('branchHastaneProducts').textContent);
        const branchCihanpolProducts = JSON.parse(document.getElementById('branchCihanpolProducts').textContent);
        
        return {
          branches: {
            hastane: {
              products: [...branchHastaneProducts, ...(savedData.branches?.hastane?.products || [])]
                .filter((v, i, a) => a.findIndex(t => t.id === v.id) === i),
              sales: savedData.branches?.hastane?.sales || [],
              expenses: savedData.branches?.hastane?.expenses || []
            },
            cihanpol: {
              products: [...branchCihanpolProducts, ...(savedData.branches?.cihanpol?.products || [])]
                .filter((v, i, a) => a.findIndex(t => t.id === v.id) === i),
              sales: savedData.branches?.cihanpol?.sales || [],
              expenses: savedData.branches?.cihanpol?.expenses || []
            }
          },
          settings: {
            ...defaultData,
            ...savedData.settings
          },
          metadata: {
            ...savedData.metadata,
            version: CONFIG.VERSION,
            modified: new Date().toISOString()
          }
        };
      }

      async loadAllData() {
        const success = await this.loadFromLocalStorage();
        if (success) {
          console.log('Veriler baÅŸarÄ±yla yÃ¼klendi');
        } else {
          console.log('Yeni veriler baÅŸlatÄ±lÄ±yor');
        }
        return success;
      }
    }

    // ================== TABLET DOSYA SÄ°STEMÄ° ==================
    class TabletFileManager {
      constructor() {
        this.fileHandle = null;
        this.directoryHandle = null;
      }

      // Tablet dosya sistemine kaydet
      async saveToTablet() {
        try {
          const backupData = {
            appState,
            cart,
            timestamp: new Date().toISOString(),
            device: navigator.userAgent,
            version: CONFIG.VERSION
          };

          // TarayÄ±cÄ± dosya sistemi API'sini kullan
          if ('showSaveFilePicker' in window) {
            const options = {
              suggestedName: `cigkofteci_yedek_${new Date().toISOString().split('T')[0]}.json`,
              types: [{
                description: 'JSON Files',
                accept: {'application/json': ['.json']},
              }],
            };

            try {
              const handle = await window.showSaveFilePicker(options);
              const writable = await handle.createWritable();
              await writable.write(JSON.stringify(backupData, null, 2));
              await writable.close();
              
              this.fileHandle = handle;
              return { success: true, filename: handle.name };
            } catch (error) {
              if (error.name === 'AbortError') {
                return { success: false, message: 'KullanÄ±cÄ± iptal etti' };
              }
              throw error;
            }
          } else {
            // Eski tarayÄ±cÄ±lar iÃ§in download linki
            return this.downloadBackupFile(backupData);
          }
        } catch (error) {
          console.error('Tablet kayÄ±t hatasÄ±:', error);
          return { 
            success: false, 
            message: `KayÄ±t hatasÄ±: ${error.message}` 
          };
        }
      }

      // Tabletten dosya yÃ¼kle
      async loadFromTablet() {
        try {
          if ('showOpenFilePicker' in window) {
            const [fileHandle] = await window.showOpenFilePicker({
              types: [{
                description: 'JSON Files',
                accept: {'application/json': ['.json']},
              }],
              multiple: false
            });

            const file = await fileHandle.getFile();
            const content = await file.text();
            const backupData = JSON.parse(content);

            // Verileri geri yÃ¼kle
            if (backupData.appState && backupData.cart) {
              appState = backupData.appState;
              cart = backupData.cart;
              
              // LocalStorage'a kaydet
              await storageManager.saveToLocalStorage();
              
              return { 
                success: true, 
                message: 'Veriler tabletten yÃ¼klendi',
                data: backupData 
              };
            } else {
              return { 
                success: false, 
                message: 'GeÃ§ersiz yedek dosyasÄ±' 
              };
            }
          } else {
            // Eski tarayÄ±cÄ±lar iÃ§in file input
            return new Promise((resolve) => {
              const input = document.createElement('input');
              input.type = 'file';
              input.accept = '.json';
              
              input.onchange = async (event) => {
                const file = event.target.files[0];
                if (!file) {
                  resolve({ success: false, message: 'Dosya seÃ§ilmedi' });
                  return;
                }

                const reader = new FileReader();
                reader.onload = async (e) => {
                  try {
                    const backupData = JSON.parse(e.target.result);
                    
                    if (backupData.appState && backupData.cart) {
                      appState = backupData.appState;
                      cart = backupData.cart;
                      
                      await storageManager.saveToLocalStorage();
                      
                      resolve({ 
                        success: true, 
                        message: 'Veriler tabletten yÃ¼klendi',
                        data: backupData 
                      });
                    } else {
                      resolve({ 
                        success: false, 
                        message: 'GeÃ§ersiz yedek dosyasÄ±' 
                      });
                    }
                  } catch (error) {
                    resolve({ 
                      success: false, 
                      message: `Dosya okuma hatasÄ±: ${error.message}` 
                    });
                  }
                };
                reader.readAsText(file);
              };
              
              input.click();
            });
          }
        } catch (error) {
          if (error.name === 'AbortError') {
            return { success: false, message: 'KullanÄ±cÄ± iptal etti' };
          }
          console.error('Tablet yÃ¼kleme hatasÄ±:', error);
          return { 
            success: false, 
            message: `YÃ¼kleme hatasÄ±: ${error.message}` 
          };
        }
      }

      // Eski yÃ¶ntem: download linki
      downloadBackupFile(backupData) {
        try {
          const jsonData = JSON.stringify(backupData, null, 2);
          const blob = new Blob([jsonData], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          
          const a = document.createElement('a');
          a.href = url;
          a.download = CONFIG.BACKUP_FILENAME;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          
          URL.revokeObjectURL(url);
          
          return { 
            success: true, 
            message: 'Dosya indirildi',
            filename: CONFIG.BACKUP_FILENAME 
          };
        } catch (error) {
          return { 
            success: false, 
            message: `Ä°ndirme hatasÄ±: ${error.message}` 
          };
        }
      }

      // Otomatik yedekleme
      async autoBackup() {
        if (!appState.settings.autoSync) return;
        
        try {
          const backupData = {
            appState,
            cart,
            timestamp: new Date().toISOString(),
            autoBackup: true,
            version: CONFIG.VERSION
          };

          // IndexedDB'ye yedekle
          if (storageManager.db) {
            await storageManager.saveBackupToIndexedDB(backupData);
          }
          
          // Her 10. otomatik yedekte tablete de kaydet
          const saveCount = parseInt(localStorage.getItem('auto_save_count') || '0');
          if (saveCount % 10 === 0) {
            await this.saveToTablet();
          }
          
          localStorage.setItem('auto_save_count', (saveCount + 1).toString());
          appState.settings.lastBackup = new Date().toISOString();
          
          return true;
        } catch (error) {
          console.error('Otomatik yedekleme hatasÄ±:', error);
          return false;
        }
      }
    }

    // ================== SENKRONÄ°ZASYON YÃ–NETÄ°MÄ° ==================
    class SyncManager {
      constructor() {
        this.isOnline = navigator.onLine;
        this.setupNetworkListeners();
      }

      setupNetworkListeners() {
        window.addEventListener('online', () => {
          this.isOnline = true;
          this.updateSyncStatus('online');
          if (appState.settings.autoSync) {
            this.syncToCloud();
          }
        });

        window.addEventListener('offline', () => {
          this.isOnline = false;
          this.updateSyncStatus('offline');
        });
      }

      updateSyncStatus(status) {
        const syncElement = document.getElementById('syncStatus');
        if (!syncElement) return;

        syncElement.className = 'sync-status';
        
        switch(status) {
          case 'syncing':
            syncElement.classList.add('syncing');
            syncElement.innerHTML = 'ğŸ”„ Senkron Ediliyor...';
            break;
          case 'synced':
            syncElement.classList.add('synced');
            syncElement.innerHTML = 'âœ… Senkron Edildi';
            setTimeout(() => {
              syncElement.innerHTML = 'âœ… Ã‡evrimiÃ§i';
            }, 3000);
            break;
          case 'error':
            syncElement.classList.add('error');
            syncElement.innerHTML = 'âŒ Senkron HatasÄ±';
            break;
          case 'online':
            syncElement.innerHTML = 'âœ… Ã‡evrimiÃ§i';
            syncElement.classList.add('synced');
            break;
          case 'offline':
            syncElement.innerHTML = 'âš ï¸ Ã‡evrimdÄ±ÅŸÄ±';
            syncElement.classList.add('syncing');
            break;
          default:
            syncElement.innerHTML = 'ğŸ”„ Bekliyor';
        }
      }

      async syncToCloud() {
        if (!this.isOnline || isSyncing) return;
        
        isSyncing = true;
        this.updateSyncStatus('syncing');
        
        try {
          // Cloudflare Workers'a senkron etme (opsiyonel)
          // Bu kÄ±sÄ±m Cloudflare Workers kurulumu gerektirir
          
          // Åimdilik localStorage'daki verileri cloud'a gÃ¶ndermeden
          // sadece durum gÃ¼ncellemesi yapÄ±yoruz
          
          await new Promise(resolve => setTimeout(resolve, 1000)); // SimÃ¼lasyon
          
          appState.settings.lastSync = new Date().toISOString();
          await storageManager.saveToLocalStorage();
          
          this.updateSyncStatus('synced');
          showSaveStatus('Cloud ile senkron edildi', 'success');
          
        } catch (error) {
          console.error('Cloud senkron hatasÄ±:', error);
          this.updateSyncStatus('error');
          showSaveStatus('Senkron hatasÄ±', 'error');
        } finally {
          isSyncing = false;
        }
      }
    }

    // ================== UYGULAMA BAÅLATMA ==================
    const storageManager = new StorageManager();
    const tabletFileManager = new TabletFileManager();
    const syncManager = new SyncManager();

    // Otomatik kaydetme interval'i
    function startAutoSave() {
      if (autoSaveInterval) clearInterval(autoSaveInterval);
      
      autoSaveInterval = setInterval(async () => {
        if (isSyncing) return;
        
        await storageManager.saveToLocalStorage();
        
        // Her 5 kayÄ±tta bir tablet yedeÄŸi al
        const saveCount = parseInt(localStorage.getItem('save_count') || '0');
        if (saveCount % 5 === 0 && appState.settings.autoSync) {
          await tabletFileManager.autoBackup();
        }
        
        localStorage.setItem('save_count', (saveCount + 1).toString());
      }, CONFIG.AUTO_SAVE_INTERVAL);
    }

    // Otomatik senkron interval'i
    function startAutoSync() {
      if (autoSyncInterval) clearInterval(autoSyncInterval);
      
      autoSyncInterval = setInterval(() => {
        if (syncManager.isOnline && appState.settings.autoSync && !isSyncing) {
          syncManager.syncToCloud();
        }
      }, 60000); // Her dakika kontrol
    }

    // ================== EVENT LISTENERS ==================
    document.getElementById('manualSaveBtn').addEventListener('click', async () => {
      const saveBtn = document.getElementById('manualSaveBtn');
      const originalText = saveBtn.innerHTML;
      
      saveBtn.innerHTML = 'â³ Kaydediliyor...';
      saveBtn.disabled = true;
      
      const result = await tabletFileManager.saveToTablet();
      
      if (result.success) {
        showSaveStatus(`Tablete kaydedildi: ${result.filename}`, 'success');
        appState.settings.lastBackup = new Date().toISOString();
        await storageManager.saveToLocalStorage();
      } else {
        showSaveStatus(`KayÄ±t baÅŸarÄ±sÄ±z: ${result.message}`, 'error');
      }
      
      saveBtn.innerHTML = originalText;
      saveBtn.disabled = false;
    });

    document.getElementById('loadBackupBtn').addEventListener('click', async () => {
      const loadBtn = document.getElementById('loadBackupBtn');
      const originalText = loadBtn.innerHTML;
      
      loadBtn.innerHTML = 'â³ YÃ¼kleniyor...';
      loadBtn.disabled = true;
      
      const result = await tabletFileManager.loadFromTablet();
      
      if (result.success) {
        showSaveStatus(result.message, 'success');
        
        // UI'Ä± yenile
        renderPOS();
        renderCart();
        renderInventory();
        renderExpenses();
        renderDashboard();
        
        alert('Tablet yedeÄŸi baÅŸarÄ±yla yÃ¼klendi!');
      } else {
        showSaveStatus(result.message, 'error');
      }
      
      loadBtn.innerHTML = originalText;
      loadBtn.disabled = false;
    });

    document.getElementById('autoSyncBtn').addEventListener('click', async () => {
      appState.settings.autoSync = !appState.settings.autoSync;
      
      const autoSyncBtn = document.getElementById('autoSyncBtn');
      if (appState.settings.autoSync) {
        autoSyncBtn.style.background = 'var(--success)';
        autoSyncBtn.style.color = 'white';
        autoSyncBtn.innerHTML = '<svg width="18" height="18" viewBox="0 0 24 24"><path d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/></svg> Oto-Senkron: AÃ‡IK';
        startAutoSync();
      } else {
        autoSyncBtn.style.background = 'var(--warning)';
        autoSyncBtn.style.color = '#000';
        autoSyncBtn.innerHTML = '<svg width="18" height="18" viewBox="0 0 24 24"><path d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z"/></svg> Oto-Senkron: KAPALI';
        if (autoSyncInterval) clearInterval(autoSyncInterval);
      }
      
      await storageManager.saveToLocalStorage();
      showSaveStatus(`Otomatik senkron: ${appState.settings.autoSync ? 'AÃ§Ä±k' : 'KapalÄ±'}`, 'success');
    });

    // ================== UYGULAMA BAÅLATMA ==================
    async function initApp() {
      // Storage'dan verileri yÃ¼kle
      await storageManager.loadAllData();
      
      // UI durumlarÄ±nÄ± gÃ¼ncelle
      document.getElementById('currentBranchName').innerText = "| Hastane Åubesi";
      
      // Tema ayarla
      const savedTheme = appState.settings.theme || 'dark';
      document.documentElement.setAttribute('data-theme', savedTheme);
      document.getElementById('themeToggle').textContent = savedTheme === 'dark' ? 'ğŸŒ™' : 'â˜€ï¸';
      
      // Otomatik senkron buton durumu
      const autoSyncBtn = document.getElementById('autoSyncBtn');
      if (appState.settings.autoSync) {
        autoSyncBtn.style.background = 'var(--success)';
        autoSyncBtn.style.color = 'white';
        autoSyncBtn.innerHTML = '<svg width="18" height="18" viewBox="0 0 24 24"><path d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/></svg> Oto-Senkron: AÃ‡IK';
      } else {
        autoSyncBtn.style.background = 'var(--warning)';
        autoSyncBtn.style.color = '#000';
        autoSyncBtn.innerHTML = '<svg width="18" height="18" viewBox="0 0 24 24"><path d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z"/></svg> Oto-Senkron: KAPALI';
      }
      
      // Senkron durumunu gÃ¼ncelle
      syncManager.updateSyncStatus(syncManager.isOnline ? 'online' : 'offline');
      
      // Otomatik kaydetme ve senkronu baÅŸlat
      startAutoSave();
      if (appState.settings.autoSync) {
        startAutoSync();
      }
      
      // Ä°lk render
      renderPOS();
      renderCart();
      renderExpenses();
      
      // Cloudflare Pages URL'sini gÃ¶ster (debug iÃ§in)
      console.log('Uygulama Cloudflare Pages Ã¼zerinde Ã§alÄ±ÅŸÄ±yor');
      console.log('Veriler tarayÄ±cÄ± belleÄŸinde saklanÄ±yor');
      console.log('Tablet yedekleme aktif');
    }

    // ================== DÄ°ÄER FONKSÄ°YONLAR ==================
    // showSaveStatus, getBranch, renderPOS, renderCart, vs...
    // Bu fonksiyonlar orijinal kodunuzdaki gibi kalacak
    // Sadece storageManager.saveToLocalStorage() kullanacak ÅŸekilde gÃ¼ncellenecek

    // Ã–rnek save fonksiyonu gÃ¼ncellemesi:
    async function save() {
      const success = await storageManager.saveToLocalStorage();
      if (success) {
        showSaveStatus('Otomatik kaydedildi', 'success');
        
        // Otomatik yedekleme kontrolÃ¼
        if (appState.settings.autoSync) {
          await tabletFileManager.autoBackup();
        }
      } else {
        showSaveStatus('Kaydetme hatasÄ±!', 'error');
      }
      return success;
    }

    // UygulamayÄ± baÅŸlat
    window.addEventListener('DOMContentLoaded', initApp);
    
    // Sayfa kapanÄ±rken son kayÄ±t
    window.addEventListener('beforeunload', async (event) => {
      await storageManager.saveToLocalStorage();
      if (appState.settings.autoSync) {
        await tabletFileManager.autoBackup();
      }
    });

    // PWA iÃ§in Service Worker
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/sw.js').then(registration => {
          console.log('ServiceWorker baÅŸarÄ±yla kaydedildi: ', registration.scope);
        }).catch(error => {
          console.log('ServiceWorker kaydÄ± baÅŸarÄ±sÄ±z: ', error);
        });
      });
    }

    // Geri kalan fonksiyonlarÄ±nÄ±z (renderPOS, renderCart, vs) aynÄ± kalacak
    // Sadece getBranch fonksiyonu appState'i kullanacak ÅŸekilde gÃ¼ncellenecek:
    function getBranch() { 
      const branchKey = document.getElementById('branchSelect').value;
      return appState.branches[branchKey]; 
    }
  </script>
</body>
</html>